%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LIVECOMS ARTICLE TEMPLATE FOR BEST PRACTICES GUIDE
%%% ADAPTED FROM ELIFE ARTICLE TEMPLATE (8/10/2017)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PREAMBLE
\documentclass[9pt,tutorial]{livecoms}
% Use the 'onehalfspacing' option for 1.5 line spacing
% Use the 'doublespacing' option for 2.0 line spacing
% Use the 'lineno' option for adding line numbers.
% Use the "ASAPversion' option following article acceptance to add the DOI and relevant dates to the document footer.
% Use the 'pubversion' option for adding the citation and publication information to the document footer, when the LiveCoMS issue is finalized.
% The 'bestpractices' option for indicates that this is a best practices guide.
% Omit the bestpractices option to remove the marking as a LiveCoMS paper.
% Please note that these options may affect formatting.

% NOTES
% when importing references from EndNote, remove the type = {Journal Article}. It messes with the livecoms bibtex style somehow...
% Place a \@ between all-caps words and punctuation ("This is a sentence about GIST\@. This is ...")
% Place a protected space (~) between "Figure" and the reference. The same with tables.

\usepackage{lipsum} % Required to insert dummy text
\usepackage[version=4]{mhchem}
\usepackage{siunitx}
\DeclareSIUnit\Molar{M}
\usepackage[italic]{mathastext}
\graphicspath{{figures/}}

\usepackage{listings}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% IMPORTANT USER CONFIGURATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\versionnumber}{1.3}  % you should update the minor version number in preprints and major version number of submissions.
\newcommand{\githubrepository}{\url{https://github.com/myaccount/homegithubrepository}}  %this should be the main github repository for this article

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% ARTICLE SETUP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{This is the title [Article v\versionnumber]}

\author[1*]{Firstname Middlename Surname}
\author[1,2\authfn{1}\authfn{3}]{Firstname Middlename Familyname}
\author[2\authfn{1}\authfn{4}]{Firstname Initials Surname}
\author[2*]{Firstname Surname}
\affil[1]{Institution 1}
\affil[2]{Institution 2}

\corr{email1@example.com}{FMS}  % Correspondence emails.  FMS and FS are the appropriate authors initials.
\corr{email2@example.com}{FS}

\orcid{Author 1 name}{AAAA-BBBB-CCCC-DDDD}
\orcid{Author 2 name}{EEEE-FFFF-GGGG-HHHH}

\contrib[\authfn{1}]{These authors contributed equally to this work}
\contrib[\authfn{2}]{These authors also contributed equally to this work}

\presentadd[\authfn{3}]{Department, Institute, Country}
\presentadd[\authfn{4}]{Department, Institute, Country}

\blurb{This LiveCoMS document is maintained online on GitHub at \githubrepository; to provide feedback, suggestions, or help improve it, please visit the GitHub repository and participate via the issue tracker.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PUBLICATION INFORMATION
%%% Fill out these parameters when available
%%% These are used when the "pubversion" option is invoked
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pubDOI{10.XXXX/YYYYYYY}
\pubvolume{<volume>}
\pubissue{<issue>}
\pubyear{<year>}
\articlenum{<number>}
\datereceived{Day Month Year}
\dateaccepted{Day Month Year}


%%% Shortcuts and macros
\newcommand{\dgsolv}{\Delta G_\textup{solv}}
\newcommand{\software}{\emph}
\newcommand{\todo}{\textcolor{red}}
\newcommand\inlinecode{\texttt}

\lstset{
	basicstyle=\ttfamily\footnotesize
}
\lstdefinestyle{code}{}
\lstdefinestyle{python}{
	language=Python,
	stringstyle=\color[rgb]{1.0, 0, 0},
	commentstyle=\color[rgb]{0, 0, 0.6}
}
\lstset{style=code}

\DeclareSIUnit{\calorie}{cal}
\DeclareSIUnit{\kcalPerMolASqr}{\kilo\calorie\per\mole\per\angstrom\squared}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% ARTICLE START
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{frontmatter}
\maketitle

\begin{abstract}
Grid inhomogeneous solvation theory (GIST) is a method to compute the free energy of hydration of a compound on a 3-dimensional grid.
The high spatial resolution of the GIST output, as well as the decomposition into energy and entropy contributions, allow for highly detailed analyses on both proteins and small molecules. However, this versatility also comes with a higher entry barrier for new users.

In this tutorial, we aim to guide the reader through the most common steps involved in a GIST analysis at the example of the streptavidin-biotin complex.
Furthermore, we discuss the theory of GIST with a focus on practical aspects, and show several pitfalls and technical difficulties that may occur during a GIST study.
We assume familiarity with molecular dynamics (MD) simulations as well as the AmberTools package.

%This particular document provides a skeleton illustrating key sections for a Tutorial document.
%Please see the sample \texttt{sample-document.tex} in \url{github.com/livecomsjournal/article_templates/templates} for additional information on and examples of using the LiveCoMS LaTeX class.
%Here we also assume familiarity with LaTeX and knowledge of how to include figures, tables, etc.; if you want examples, see the sample just referenced.
%
%In your work, in this particular slot, please provide an abstract of no more than 250 words.
%Your abstract should explain the main contributions of your article, and should not contain any material that is not included in the main text.
%Please note that your abstract, plus the authorship material following it, must not extend beyond the title page or modifications to the LaTeX class will likely be needed.
\end{abstract}

\end{frontmatter}




\section{Introduction}
\todo{ (vah) Sources and better description of all these methods, more literature research, better flow }


Solvation thermodynamics govern any process involving solutes in a solvent.
Solutes are constantly interacting with solvents in their environment, necessitating a good description of these interactions for accurate computational predictions. 
Especially the interaction with water is of utmost importance, as many biological processes occur in a aquaeous environment. 
The free energy of solvation thereby strongly influences real-world problems of interest such as hydrophobic effects, the binding of a ligand to a protein, protein-protein interactions, protein dynamics or even more generally, a protein's fold. 
The computational calculation of thermodynamical solvation properties is therefore of particular interest and has been tackled by a wide array of different methods.   
Quantum mechanical methods provide the most rigorous description of the underlying potential energy surface (PES) but suffer from high computational cost, allowing only the treatment of small systems and few solvent molecules. 
More recently, machine learning approaches and QM/MM approaches are trying to bridge the gap to computationally less demanding methods while keeping the accuracy of ab initio QM methods.
Molecular mechanics based approaches describe the underlying PES through empirically fit force-fields, which reduce the computational demand of these calculations tremendously.
This allows for the treatment of even large biological systems like fully solvated proteins. 
Implicit solvent methods such as MM/PBSA  or MM/GBSA can quickly provide results for a large amount of supplied structures, but yield inaccurate results when compared to more rigorous explicit solvent methods. Somewhat inbetween the implicit solvent methods and the fully explicit solvent methods are Reference Interaction Site Models. One of these methods, 3D-RISM, foregoes the explicit simulation and uses 3D solvent distributions based on the Ornstein--Zernike integral equations to predict solvation thermodynamics instead.
The 3D-RISM approach allows for a decomposition into entropic and enthalpic terms as well as a full localization of the underlying distributions to the solute structure.
The most statisticaly rigorous of the explicit solvent MM methods are alchemical methods such as FEP or TI. 
Assuming sufficient sampling, they can accurately predict the free energy of solvation in the boundaries of the assumptions underlying their forcefield. 
However, the seperation of enthalpic and entropic contributions to the free energy of solvation is difficult with these methods and localizing these contributions not easily possible.
In this tutorial, the Grid Inhomogenous Solvation Theory (GIST) is applied to calculate solution thermodynamic properties of interest. 
GIST is based on Lazaridis' Inhomogenous Solvation Theory (IST), solving the arising integral equations on a grid. 
This is highly advantegous compared to other IST-based methods such as e.g. WaterMap,\todo{Add more methdods!} as this is not restricted to high-occopancy solvation sites but provides a 
By simulating the dynamics of a solvent around the solute, GIST calculates thermodynamic properties for a standard solvation process as described by Ben-Naim.
The method allows for a full localization of entropic and enthalpic contributions on the grid around the solute.
For small organic molecules in water, the method provided results compareable to TI in accuracy, assuming some small correction factor to the entropy is applied. 
Recent improvements to the method have improved the calculation speed tremendously, allowing for the treatment of larger systems of biological interest such as proteases or antibodies. 
Other improvements worked on decreasing differences in the treatment of long-range interaction energies between GIST and popular molecular dynamics engines. 
Yet further changes allow the inclusion of other rigid solvents than water or allow for the treatment of solvent mixtures and ions in solution. 
While previous tutorials gave insightful pointers as to how to setup and run GIST calculations, the post-processing of such calculations was often treated less rigorously. While building on these tutorials, an updated guide to calculating solvation properties using GIST is therefore presented here to address the recent improvements to the method.

%Here you would explain what problem you are tackling and briefly motivate your work.
%
%In this particular template, we have removed most of the usage examples which occur in \texttt{sample-document.tex} to provide a minimal template you can modify; however, we retain a couple of examples illustrating more unusual features of our templates/article class, such as the checklists, and information on algorithms and pseudocode.
%
%Keep in mind, as you prepare your manuscript, that you should plan for a representative image  which will be used to highlight your article on the journal website and publications. Usually, this would be one of your figures, but it must also be uploaded separately upon article submission. We give specific guidelines for this image on the journal website in the section on article submission (see \url{https://livecomsjournal.github.io/authors/policies/index.html#article-submission}).
%
%Additionally, for well-formatted manuscripts, we recommend that you let LaTeX handle figure/table placement for you as much as possible, so please avoid specifying strenuous float instructions like `[h!]` and `[H]` as much as possible.

\subsection{Scope}

The tutorial provides an example of a GIST workflow that can be easily adapted towards different systems. 
In addition to a short introduction to the method and the theory behind it an overview of the various different flavours of GIST methods is provided.
Towards this, a GIST study of the streptavidin-biotin complex is presented, which reflects on many common aspects of GIST studies.
We present solvation analysis of a small molecule (biotin) as well as a biomolecule (streptavidin).
For both systems, we show how to interpret the three-dimensional contributions of solvation free energy in a binding pocket.
The contribution of solvation free energy to binding is computed, which requires accurate post-processing of the GIST output to avoid unfavorable summation of bias in the GIST calculation.
We believe that this example study covers a wide range of applications of the GIST method.
Furthermore, we discuss several technical aspects  and typical pitfalls of GIST analyses, such as the normalization of voxel values and how to deal with double counting of energy contributions. 
Additionally, we provide a python library to unify the analysis of GIST data produced by various versions of GIST and make the post-processing of GIST results more accessible.

After completing this tutorial, we expect the reader to be able to implement their own GIST study. 

%Tutorials should endeavor to cover the specific task at hand, and also highlight how the steps might need to be modified (or additional care might need to be taken at particular points) to handle more general cases.
%
%The scope of the tutorial, as well as the expected proficiencies / outcomes for researchers who complete the tutorial, should be clearly defined.
%This will often happen in a specific section or subsection in the article itself.

\section{Prerequisites}
\todo{ (vah)  Improve flow and logical progression of prerquisites.}

%Here you would identify prerequisites/background knowledge that are assumed by your work, as well as any software/license requirements.

\subsection{Background knowledge}
This tutorial is aimed at advanced users with a solid background knowledge of molecular dynamics (MD) simulations. The user should be able to run MD simulations and work with their output data.
Previous knowledge of the method is not necessary, but we recommend the perusal of the primary sources on the method outlined in the Theory section. 

The presented analyses are run in Python.
A working understanding of Python is therefore necessary to follow the tutorial. 
A Jupyter notebook showing directly the herein presented analyses is provided as well. 
To easily follow the analyses an understanding of working with Jupyter notebooks is therefore beneficial, though not strictly necessary.

\subsection{Software/system requirements}
%Tutorials should clearly define what system and/or software requirements the researcher will need to complete the tutorial (e.g., VMD version 1.9 or newer, AMBER, etc.). Tutorials requiring specific software packages must provide instructions and files for the referenced version of the software.
GIST's main implementation is part of the MD analysis software \software{cpptraj} as part of the AmberTools software suite.
A recent version of \software{cpptraj} should be used, such as the one in AmberTools22 or an installation from GitHub.
The closed-source Amber simulation engine is used in this tutorial to run the necessary MD simulations. 
If no Amber installation is available, the MD can be performed other simulation engines compatible with \software{cpptraj}, we recommend GROMACS.
If using GROMACS, we propose to prepare the structures and topologies using AmberTools and then converting to GROMACS using \software{acpype.py}.
In that way, a full Amber topology is available for the GIST analysis.

Furthermore, a recent Python version (>3.6) should be available with the following packages.
\begin{itemize}
	\item \software{gisttools} (and its prerequisites)
	\item \software{mdtraj}
\end{itemize}
If the reader prefers to skip the MD and GIST calculation, we also provide the GIST output files with this tutorial, such that the post-processing can be done without any expensive calculations. A Jupyter notebook showing the herein presented analyses is provided as well, necessitating a current installation of Jupyter to run.


\section{Theory}
GIST is an implementation of Inhomogeneous Solvation Theory (IST) \cite{Lazaridis1998} that discretizes  the free energy of solvation $\dgsolv$ on a three-dimensional grid. 
It was first devised by Nguyen et al. \cite{Nguyen2012} to overcome the limitation of IST which was commonly used for regions of high water occupancy and its implementation in \software{cpptraj} was thoroughly described in \cite{Ramsey2016}.
Here, we only provide a short overview of the theory behind GIST.
For more detailed information, we recommend one of the more recent publications on developments in GIST. \cite{Kraml2020}\cite{Chen2021}


\subsection{Solvation Entropy}
The solvation entropy of a system is totality of the contribution of the  solute-water entropy and the water-water entropy. 

\begin{equation}
	\Delta S_\textit{solv} = \Delta S_\textit{sw} + \Delta S_\textit{ww}
\end{equation}
Here the solvation entropy is approximated from the contribution of solute-water interaction. 
\textbf{STILLNEEDS REVISON + ADD CITATIONS} The quantity $k_\textit{b}$represents the Boltzman constant, 
$\rho^\textit{o}$ is the bulk number density, $g_\textit{sw}\left(\textbf{r},\omega \right)$ is the solute-water 
pair correlation function in the solute's frame of reference, \textbf{r} is the coordinates of the oxygen atom of the water molecule,  
$\omega$ is the Euler angle, and the factor $\frac{1}{8\pi^2}$ is the normalization constant. In bulk and in regions where the orientational 
entropy is uniform, the quantity $g_\textit{sw}\left(\textbf{r},\omega \right)$ is unity which leads to the first-order solvation entropy of 
bulk to be zero. Also, this quantity reaches unity as the distance from the solute molecule increases which leads for the calculation of 
the solvation entropy to be an approximation of the integral around the solute atom. 

\begin{equation}
	\Delta S_\textit{solv} \approx \Delta S_\textit{sw} \equiv -k_\textit{B} \frac{\rho^\textit{0}}{8\pi^\textit{2}} \int g_\textit{sw} \left(\textbf{r}, \omega \right) d\textbf{r}d\omega
\end{equation}

The solvation entropy is further broken down in terms of the contribution from translational and orientational terms.
\begin{equation}
	\Delta S_\textit{solv} = \Delta S_\textit{trans} + \Delta S_\textit{orient}
\end{equation}

\subsection{Entropy Calculations in Cpptraj}
In \software{cpptraj} the calculation of  solvation entropy is handled into two methods.

The first method assumes that the position ($r$) is independent of the orientation ($\omega$). This approximation allows for the 
splitting of the contributions of the translational and the orientational entropy. The nearest neighbor (NN) approach is used to 
evaluate each expression where $N_\textit{k}$ is the number of water molecules found in voxel k, $\gamma$ is the Euler's constant 
that accounts for the bias in naive entropy estimator, and $g_\textit{NN}$ is the nearest neighbor estimate. In the nearest neighbor
estimate, a voxel is considered to be a neighboring voxel when it shares any vertices of the voxel of interest. 
\begin{equation}
	g_\textit{vox} \left( \textbf{r}, \mathbf{\omega} \right) \approx g_\textit{vox} \left( \textbf{r})g_\textit{vox}(\mathbf{\omega} \right)
\end{equation}

\begin{equation}
	S_{k}^\textit{trans} \approx \frac{-R}{N_\textit{k}} \left( \sum _{i=1}^{N_k} ln g_{NN, \textit{i}} \left( \textbf{r} \right) + \gamma \right)
\end{equation}


\begin{equation}
	S_{k}^\textit{orient} \approx \frac{-R}{N_\textit{k}} \left( \sum _{i=1}^{N_k} ln g_{NN, \textit{i}} \left( \mathbf {\omega} \right) + \gamma \right)
\end{equation}

The second method directly calculates the solvation entropy by evaluating the six-dimensional integral (3 for position and 3 for orientation) 
using the nearest-neighbor approach. Unlike the first method, the nearest neighbor estimate for the sixth-order entropy considers all the water 
found within the same and neighboring voxels.  
\begin{equation}
	S_\textit{k} \approx \frac{-R}{N_\textit{k}} \left( \sum _{i=1}^{N_k} ln g_{NN, \textit{i}} \left( \textbf{r}, \mathbf {\omega} \right) + \gamma \right)
\end{equation}


\subsection{Solvation Energy}
The solvation energy is readily calculated by summing up the contributions of the water-water interaction and the water-solute interaction.
\begin{equation}
	\Delta E_\textit{solv} = \Delta E_\textit{sw} + \Delta E_\textit{ww}
\end{equation}

\begin{equation}
	\Delta E_\textit{sw} \equiv \frac{1}{8\pi^2} \int g_\textit{sw}\left(\omega|\textbf{r}\right) U_\textit{sw}\left(\textbf{r}, \omega\right) d\omega
\end{equation}

Similar to the entropy integrals, the solute-water solvation energy integral also decays with increasing distance from the solute. Hence, the solvation energy can be approximated by local spatial integrals. However, there is a complication arising from this approximation. Water molecules outside the region of interest will also be accounted for in the pairwise water term. For example, given two different regions $R_a$ and $R_b$, will not sum up to the total energy of the two regions due to double counting. 

\begin{equation}
\begin{aligned}
	\Delta E_\textit{ww} \equiv & \left(\frac{1}{8\pi^2} \right)^2 \rho^o \int g_\textit{sw}\left(\omega|\textbf{r}\right) \\
	& \times \left[g_\textit{sw}\left(\textbf{r}^\prime , \omega^\prime \right) - g^o_\textit{ww} \left(\textbf{r}, \omega, \textbf{r}^\prime, \omega^\prime \right)\right] \\
	& \times U_\textit{ww}\left(\textbf{r}, \omega, \textbf{r}^\prime, \omega^\prime\right)d\omega d\textbf{r}^\prime d\omega^\prime
\end{aligned}
\end{equation}
There are two ways in which this double counting was accounted for in the original paper. First, using the water-displacement method. This method is applicable when a determining the energetic cost of kicking out a water molecule. 
\begin{equation}
	\Delta E^R_\textit{ww} = n^\textit{R} E^\textit{bulk}_\textit{ww} - E^\textit{R,corr}_\textit{ww}
\end{equation}

The second method uses normalized-water properties to account the difference in water properties of two different regions. The normalized water property is defined as the water property per water molecule. 
\begin{equation}
	\Delta E^\textit{R,norm}_\textit{ww} = E^\textit{R,norm}_\textit{ww} - 2E^\textit{bulk}_\textit{ww}
\end{equation}

\subsection{PME implementation}

In the latest implementation of GIST, the particle mesh ewald (PME) functionaliy was added that decomposed the contributions of the PME-based electrostatic energy and the long-range Lennard-Jones energy to the total solvation energy. This allows  for a faster and more accurate calculation of the solvation energy.

\begin{equation}
	E_\textit{total} = E_\textit{elec} + E_\textit{lj}
\end{equation}

In the original version of GIST, the energies are calculated based on the shortest distance or the minimum image convention. In doing so, long range interactions are not accounted for. In the PME functionality, the contribution of the long-range interactions are accounted for.

In terms of the electrostatic energy, in the original version, the electrostatic energy longer than half of the cell's diagonal are not accounted for. In the PME functionality, the long-range interactions are accounted for by decomposing the electrostatic interaction into three parts: the direct term, the reciprocal term, and the correction term. 

\begin{equation}
	E_\textit{elec} = E_\textit{dir} + E_\textit{rec} + E_\textit{corr}
\end{equation}

On the other hand, in PME-GIST, the long-range interactions for the Lennard-Jones contribution are treated by accounting for the short-range and the long-range correction contributions separately. The short-range contribution is the LJ energy within the set cutoff and the long-range correction term accounts for the contributions above this cutoff.

\begin{equation}
	E_\textit{lj} = E_\texit{lj\_short} +  E_\textit{corr}
\end{equation}

\section{Tutorial}
Here, we aim to guide the reader through a GIST analysis of the streptavidin-biotin complex. The goal is to
\begin{enumerate}
	\item compute the binding free energy of the complex from the individual energy contributions combined with the contribution of hydration computed using GIST.
	\item visualize local contributions to $\dgsolv$ in the streptavidin binding pocket as well as around biotin.
\end{enumerate}

\subsection{Streptavidin/Biotin}
\subsection{Tutorial data}
We will use the 1STP crystal structure to start our calculations.
For the sake of simplicity, you can download prepared and solvated Amber topologies and structures based on 1STP by running
\begin{lstlisting}
git clone git@github.com:liedllab/gist-tutorial.git
\end{lstlisting}
This will download the tutorial files (including both the manuscript and the examples in the \software{code} folder).
\subsection{System Preparation and Equilibration}
If you want to skip this section, run 
\begin{lstlisting}
make equilibration-targets
\end{lstlisting}
in the code folder. This assumes that you have Python and Amber set up properly and that \software{pmemd.cuda} is in the PATH.

When calculating solvation free energy differences between a complex and the corresponding monomers (the dissociated state), there are two options for dealing with configurational diversity in the structures.
\todo{Maybe Valentin knows a citation for that?}
One can choose to sample the complex and dissociated states individually, or to sample only one of them and assume that there is sufficient overlap in the sampled conformations.
%One can choose to sample only the complex, assuming that all relevant conformations of the dissociated state are also found in the complex.
%The probability distribution of the dissociated state can be obtained by reweighting the probabilities in the complex using the solvation free energies.
%Alternatively, one can sample the complex and dissociated states individually.
%This approach does not require an overlap between the conformational probabilities of the complex and dissociated states.
%However, it is prone to statistical errors due to uncertainties in the ensembles, and requires the free energy contributions from the internal degrees of freedom of the monomers (in both the complex and the monomer states) to be known. \todo{This paragraph does not fit here well. Maybe put it somewhere else.}

Here, we choose not to include any sampling of the conformational states. 
It is therefore important that the conformations of the monomers in the complex and dissociated states match exactly. 
Use \software{cpptraj} to produce biotin and streptavidin structures based on the complex by stripping the respective other molecule like this:
\begin{lstlisting}
parm complex/solvated.parm7
trajin complex/equil/EQUIL-DONE.rst
strip ^2 parmout streptavidin/solvated.parm7
trajout streptavidin/pre-equil.ncrst
\end{lstlisting}
(Adapt for biotin as necessary.)

%We provide a script called \software{cpptraj\_remove\_mol.sh} that removes a single molecule from a topology and structure using \software{cpptraj} without altering the rest of the system. \todo{Explain cpptraj rather than our script. The script is for the automated workflow only.}

Use the \software{equilibration.py} script (or your own) to perform short NVT and NpT equilibration runs on the starting structure.
Note that the barostat might interfere with restrained equilibration of the complex, since different molecules are moved relative to each other when the volume changes.
But since our equilibration script also contains unrestrained pressure equilibration, we should not run into any trouble.

Then split the equilibrated structure into biotin and streptavidin parts using \software{cpptraj\_remove\_mol.sh}.
After that, you can use \software{equilibration.py -R} to run short restrained equilibrations (where only the water is allowed to move) on the individual systems.

\subsection{Running MD for GIST}

Now, you can run restrained MD simulations based on the equilibrated structures for subsequent GIST analyses.
We apply a harmonic restraint of \SI{100}{\kilo\calorie\per\mole\per\angstrom\squared} to all heavy atoms to keep the system in place.
We run \SI{100}{\nano\second} of simulation and store the conformations every \SI{100}{\pico\second}.
A simulation length of at least \SIrange{10}{20}{\nano\second} is recommended, to obtain statistically independent snapshots of the water.

An example Amber input file for GIST might look like this:
\begin{lstlisting}
restrained 100 ns NpT
&cntrl
  ntx=5, irest=1,
  ioutfm=1,
  ntb=2, iwrap=1,
  ntr=1, restraint_wt=100.0,
    restraintmask="!@H=&!:WAT",
  ntp=1, pres0=1.0, taup=1.0,
  ntc=2, ntf=2,
  ntt=3, tempi=300.0, temp0=300.0, gamma_ln=2,
  nstlim=50000000, dt=0.002,
  ntwr=50000, ntwx=5000,
  ntpr=5000,
/
\end{lstlisting}
Note that these are very standard MD settings except for the line that defines the restraints.

Run the MD using \software{pmemd.cuda}:
\begin{lstlisting}
pmemd.cuda \
	-O \
	-i 100ns-npt-restraint.in \
	-o md-01.out \
	-p solvated.parm7 \
	-c EQUIL-DONE.rst \
	-x md-01.nc \
	-r md-01.ncrst \
	-ref EQUIL-DONE.rst
\end{lstlisting}
\subsection{Running the GIST analysis}

For easier post-processing, we will use grids that contain the whole molecule.
This could in theory be avoided for streptavidin and the complex, since only the surrounding of the biotin molecule (i.e., the binding pocket) is required for the analysis.
We also recommend that you center the molecule in space.
For each system (biotin, streptavidin, complex), produce a centered pdb file using \software{cpptraj}:
\begin{lstlisting}
parm solvated.parm7
trajin md-01.nc 1 1 1
autoimage !(:WAT) origin
strip :WAT
trajout solute-centered.pdb
\end{lstlisting}
Then, find the extent (minimum and maximum) of the x-, y-, and z-coordinates for each system.
This can be done e.g., using the \software{mdtraj} package in Python.
\begin{lstlisting}[style=python]
import mdtraj as md
pdb = md.load("solute-centered.pdb")
# mdtraj converts to nm.
# *10 to convert back to Angstrom.
min = pdb.xyz[0].min(0) * 10.
max = pdb.xyz[0].max(0) * 10.
print(*list(zip("xyz", min, max)), sep="\n")
\end{lstlisting}
Then, decide on grid dimensions for every system.
For a system centered at the origin with a spacing of \SI{0.5}{\angstrom} and a buffer of, e.g., \SI{7}{\angstrom} between the solute and the grid wall, you need $4.0\times (d+7)$ bins in the respective direction, where $d$ is the larger of $-$min and $+$max in the respective direction.
\todo{this does not work with the default gisttools values for the automatic detection of the energy reference. Better use a larger value. }
We note that this centered grid is usually larger than it needs to be in some directions.
If you want to save some extra memory and calculation time, feel free to align the grid more precisely to the minimum and maximum coordinates, or use a smaller grid that only covers the binding pocket.
You can also rotate the molecule by its principal axes to fit the cuboid grid more exactly.
However, this needs to be done \emph{before} the MD run, since rotating the trajectory damages the periodic box information.

Now, you can finally run the actual GIST analysis. Center the molecule exactly in the same way as above, to make sure that its position matches the grid parameters that you decided on.
We recommend using either the PME or GPU implementation of GIST, depending on whether you have a fast GPU.
A further advantage of the PME implementation is that it matches the energy calculation of the MD engine more closely.
\todo{At the time of writing, it is important to use an up-to-date version of PME-GIST, or the Esw-Eww decomposition will not be available. Maybe remove this for the final version, when Amber22 is out.}
\begin{lstlisting}
parm solvated.parm7
trajin md-01.nc
autoimage !(:WAT) origin
# remove the "pme" option if you want to use the GPU
gist griddim 100 100 100 out gist.dat \
  refdens 0.03287 pme
# other settings you might want to change
# (those are the defaults)
# gridcntr 0 0 0 gridspacn 0.5 temp 300
\end{lstlisting}
\subsection{Reference Values and Radial Convergence}
All GIST quantities should be expressed relative to bulk. In practice, this is not problematic for the entropies, since they are computed relative to a distribution of randomly oriented molecules at the reference density.
The solute-solvent energy Esw is also no problem, because it naturally tends to zero in bulk. 
However, the solvent-solvent energy Eww needs to be referenced.

The Amber manual provides reference energies for several solvents.
However, the exact reference value is different when using PME-GIST, and also depends on the box size.
For exact analyses such as computing the total $\dgsolv$ of a compound, it is important to compute an exact reference energy.

The most accurate method to compute a reference energy is to run a separate GIST calculations with the same energy method (PME/GPU) and a similar box size, and then compute the average solvent-solvent energy per molecule.

\begin{equation}
\label{eq_ewwref}
E_{ww}^\textit{ref} = \frac{\int{E_{ww}} \mathrm{d}x}{\left<N_\textit{solvent}\right>}
  = \frac{\sum_\textit{voxels}E_{ww}^\textit{dens} V_\textit{vox}}{\sum_\textit{voxels}{N_\textit{solvent}} / N_\textit{frames}}
\end{equation}

Alternatively, one can note that the solvent-solvent energy in a sufficiently large GIST grid converges to the correct bulk value at large distance to the solute.
This means that the reference energy can be obtained from a large GIST grid by binning the voxels by their distance to the solute, and evaluate Equation~\ref{eq_ewwref} within each bin.
If this value converges to a constant, this can be used as $E_{ww}^\textit{ref}$.

\software{gisttools} contains functionality to perform this analysis easily.
There is also a method \inlinecode{detect\_reference\_value} that automatically tries to find the converged value fo the rdf.
Although it has a simple convergence check built-in, it is always recommended to check the convergence by hand as well.

\begin{lstlisting}[style=python]
import gisttools as gt
import matplotlib.pyplot as plt
gist = gt.gist.load_gist_file(
    "gist.dat", struct="solute-centered.pdb")
bins, eww = gist.rdf(
    "Eww_unref_norm", bins=100, rmax=20., normalize="norm")
plt.plot(bins, eww)
eww_auto = gist.detect_reference_value().values[0]
plt.axhline(eww_auto, color='k')
plt.gca().set(
    xlabel='distance [A]', ylabel='E_ww per mol')
plt.show()
\end{lstlisting}

The expected output of this code is shown in Figure~\ref{fig_ewwref}.

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{figures/Eww_convergence.eps}
	\caption{Convergence of $E_{ww}$ with increasing distance to the solute. The horizontal line shows the automatically computed reference energy. Computed from the complex calculation.}\label{fig_ewwref}
\end{figure}

After choosing an appropriate reference value, we need to subtract this value from Eww.
Make sure to subtract the reference from the normalized (\_norm) data.
In \software{gisttools}, this is done simply by setting \inlinecode{gist.eww\_ref}.
In \software{gistpp}, this can be done as follows: \todo{This might become invalid with future GIST versions, depending on whether we adopt the COM as molecular center.} \todo{Better use the population.}

\begin{lstlisting}
rho0=0.03287465
neg_eww_ref=9.533
gistpp -op multconst -i gist-gO.dx -opt const $rho0 \
    -o gist-gO-abs.dx 
gistpp -op div -i gist-Eww-dens.dx -i2 gist-gO-abs.dx \
    -o gist-Eww-norm.dx
gistpp -op addconst -i gist-Eww-norm.dx \
    -opt const $neg_eww_ref -o gist-Eww-ref-norm.dx
gistpp -op mult -i gist-Eww-ref-norm.dx \
    -i2 gist-gO-abs.dx -o gist-Eww-ref-dens.dx
\end{lstlisting}

Now, add all free energy contributions to obtain the spatially resolved $\dgsolv$.
In \software{gisttools}, this is done automatically (simply use the \inlinecode{A\_dens} and \inlinecode{A\_norm} columns).
In \software{gistpp}, use the \inlinecode{add} command, with the same syntax as the \inlinecode{div} command used above.
After that, check whether your free energy contributions become negligible at high distances to the solute.
In a plot like Figure~\ref{fig_ewwref} based on the \inlinecode{A\_dens} column, the values should tend to zero.
However, it is more informative to plot the cumulative free energy contribution against the distance to the solute, to check the convergence.
It the curve flattens out, this is your final $\dgsolv$\@.
If it does not, you might need to tweak the Eww reference, or introduce a reference value for the entropy (especially with older versions of \software{cpptraj}).

\begin{lstlisting}[style=python]
import gisttools as gt
import matplotlib.pyplot as plt
# adapt eww_ref!
gist = gt.gist.load_gist_file("gist.dat",
    struct="solute-centered.pdb", eww_ref=-9.533)
bins, (dg, esw, eww, s) = gist.rdf(
    ["A_dens", "Esw_dens", "Eww_dens", "dTSsix_dens"],
    bins=100, rmax=20., normalize="none")
plt.plot(bins, np.cumsum(dg), label="dG")
plt.plot(bins, np.cumsum(eww), label="Eww")
plt.plot(bins, np.cumsum(esw), label="Esw")
plt.plot(bins, np.cumsum(s), label="dS")
\end{lstlisting}

The expected output of this code is shown in Figure~\ref{fig_radial_convergence}.
In this case, both the Eww energy and the entropy are not perfectly flat, indicating that the reference value is not optimal.
The slow energy convergence indicates that a non-optimal reference value was used, but is also complicated by the fact that a charged solute is used without neutralizing counter ions.


\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{figures/A_E_S_convergence.eps}
	\caption{Convergence of $\dgsolv$ and its contributions with increasing distance to the solute. All quantities cumulative, i.e., summed up to the respective radius. Computed from the biotin calculation.}\label{fig_radial_convergence}
\end{figure}

\subsection{Visualizing $\dgsolv$}
Next, we want to visualize the 3-dimensional contributions to the free energy of hydration, as well as the entropy and enthalpy contributions.
You can use PyMol\cite{pymol} or VMD\cite{vmd} to visualize the .dx files from GIST\@.
With \software{gistpp}, you can use the file from the convergence check. Additional OpenDX files can be produced using \inlinecode{gistpp -op makedx}.
With \software{gisttools}, you can create one using e.g., \inlinecode{gist.save\_dx("A\_dens", "A\_dens.dx")}.

It might also be interesting to visualize the average energy of a water molecule at each grid voxel.
This quantity is given by 2*Eww + Esw.
The energy referencing leads to non-zero normalized values where the population is zero.
While this is irrelevant for further post-processing, it is advantageous for visualization to set those empty regions to zero.
An OpenDX file can be produced using \software{gisttools} as follows:

\begin{lstlisting}[style=python]
import gisttools as gt
gist = gt.gist.load_gist_file("gist.dat",
    struct="solute-centered.pdb", eww_ref=-9.533)
gist['E_norm'] = gist['Eww_norm'] * 2 + gist['Esw_norm']
gist.loc[gist['population'] == 0, 'E_norm'] = 0
gist.save_dx('E_norm', 'gist-E-per-mol-norm.dx')
\end{lstlisting}

Visualize the free energy, the total energy, and the entropy, at several iso-levels.
An minimal PyMOL input might look like this:

% The current font makes the O look like a tofu / placeholder
\begin{lstlisting}
load solute-centered.pdb
show sticks, resname BTN
as surface, not resname BTN
load gist-gO.dx, gO
isosurface gO_high, gO, 2.
\end{lstlisting}

Adapt the above PyMOL script to visualize the average energy per solvent at a positive and a negative isolevel, as well as regions of negative entropy per solvent.
The expected representation of the streptavidin binding pocket is shown in Figure~\ref{fig_binding_pocket_pymol}.

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{figures/binding_pocket_S_-2_E_-2_E_3.png}
	\caption{Free energy contributions in the streptavidin binding pocket. Red: high solvent energy (at +3 kcal/mol). Blue: low solvent energy (at -2 kcal/mol). Green: low solvent entropy $T\Delta S^{six}$ (at -2 kcal/mol).}\label{fig_binding_pocket_pymol}
\end{figure}

You should find that there are several regions in the binding pocket that feature a high solvent energy and/or low solvent entropy.
However, such regions also exist outside of the binding pocket, and there are also low-energy regions within the binding pocket.
Therefore, the strong affinity to biotin can not be explained solely by the hydration contribution, and the direct interaction energy also needs to be taken into account.

\subsection{Contribution of Hydration to Binding}
In the next step, calculate the $\dgsolv$ contributions around the biotin ligand in each of the three systems (biotin, streptavidin, and complex).
Note that our integration region does not fully reach into bulk, but also comprises regions that are close to the streptavidin protein. 
Therefore, our results for each system will depend on the exact position of the integration boundary. 
To avoid inconsistencies, it is important to choose exactly the same integration region for each system.
Although we kept the systems rigid, the center of mass might have been shifted during pressure equilibration.
Therefore, we align the complex structure to the streptavidin system and use the shifted biotin coordinates to define the integration region.

We recommend using a \software{Jupyter Notebook} for the following analyses, although they can also be done in a script or an interactive Python prompt.
The code is not explained in detail here, but should be clear after reading the previous sections.

Load the files and double check the frame numbers and reference density.
\begin{lstlisting}[style=python]
import numpy as np
from gisttools.gist import load_gist_file
import matplotlib.pyplot as plt

compl = load_gist_file('complex/gist/gist.dat', \
    struct='complex/gist/solute-centered.pdb')
print(compl.n_frames, compl.rho0)
biotin = load_gist_file('biotin/gist/gist.dat', \
    struct='biotin/gist/solute-centered.pdb')
print(biotin.n_frames, biotin.rho0)
strept = load_gist_file('streptavidin/gist/gist.dat', \
    struct='streptavidin/gist/solute-centered.pdb')
print(strept.n_frames, strept.rho0)
\end{lstlisting}

Assign reference energies and check them for plausibility.
\begin{lstlisting}[style=python]
biotin.eww_ref = biotin.detect_reference_value()
print("Biotin:", biotin.eww_ref)
strept.eww_ref = strept.detect_reference_value()
print("Streptavidin:", strept.eww_ref)
compl.eww_ref = compl.detect_reference_value()
print("Complex:", compl.eww_ref)
\end{lstlisting}

Subtract a reference entropy from the dTSsix columns.
\begin{lstlisting}[style=python]
def reference_entropy(gf):
    if 'dTSsix_unref_norm' not in gf.data.columns:
        gf['dTSsix_unref_norm'] = gf['dTSsix_norm']
        gf['dTSsix_unref_dens'] = gf['dTSsix_dens']
    gf['dTSsix_norm'] = gf['dTSsix_unref_norm'] \
        - gf.detect_reference_value('dTSsix_unref_dens')
    gf['dTSsix_dens'] = gf.norm2dens(gf['dTSsix_norm'])
reference_entropy(biotin)
reference_entropy(strept)
reference_entropy(compl)
\end{lstlisting}

Compute the atom positions that define the integration region.
For the streptavidin integral, we align the complex structure onto streptavidin and then use the biotin positions as centers.
Note that we use \software{mdtraj} here, since \software{gisttools} stores the reference structure as a \inlinecode{mdtraj.Trajectory} object, but any other library for post-processing of trajectories works as well.
\begin{lstlisting}[style=python]
col = 'dTSsix_dens'
def select(traj, sel):
    "Slice a Trajectory by selection mask."
    return traj.atom_slice(traj.top.select(sel))
# we multiply by 10 to convert nm to Angstrom.
compl_x = select(compl.struct, biotin_mask).xyz[0] * 10.
biotin_x = select(biotin.struct, biotin_mask).xyz[0] * 10.
aligned = compl.struct[:].superpose(strept.struct, \
    atom_indices=strept.struct.top.select(strept_mask))
aligned = select(aligned, biotin_mask)
strept_x = aligned.xyz[0] * 10.

bins, biotin_rdf = biotin.rdf( \
    col, centers=biotin_x, bins=100, rmax=24)
bins, strept_rdf = strept.rdf( \
    col, centers=strept_x, bins=100, rmax=24)
bins, compl_rdf = compl.rdf( \
    col, centers=compl_x, bins=100, rmax=24)
\end{lstlisting}

Now, subtract the monomer rdfs from the complex, and compute the integrals.
If you also visualize the individual rdfs, you will notice that the difference converges much better with increasing radius than the contributions.
This is because the cutoff contains regions that are close to the atom, since the integration region does not comprise the whole protein.
\begin{lstlisting}[style=python]
difference = compl_rdf - biotin_rdf - strept_rdf
cutoff = 12
integral = difference[bins < cutoff].sum()
print("Integral = {}".format(integral))
plt.plot(bins, np.cumsum(difference))
plt.axvline(cutoff)
plt.xlabel('distance to biotin [A]')
plt.ylabel('dG contribution [kcal/mol]')
\end{lstlisting}

Compute the energy (Eall) and entropy (dTSsix) contributions separately.
You will find that the energy is strongly unfavorable to binding, because we do not yet include the interaction energy between biotin and streptavidin.

Using the \inlinecode{energy} command in \software{cpptraj}, you can compute this energy difference.
We recommend using PME in combination with PME-GIST, but not with GPU-GIST\@.
An example \software{cpptraj} input might look like:
\begin{lstlisting}
parm solvated.parm7
trajin md-01.nc 1 last 100
energy complex ^1,2 # etype pme
energy strept ^1 # etype pme
energy biotin ^2 # etype pme
go
diff = complex[total] - strept[total] - biotin[total]
writedata energy.dat diff complex[total] \
strept[total] biotin[total]
avg(complex[total])
avg(strept[total])
avg(biotin[total])
avg(diff)
\end{lstlisting}

The expected results are summarized in Table~\ref{tab_dg_monomers_dimer}.

\begin{table}
	\caption{Free energy contributions for the monomers and the dimer.}\label{tab_dg_monomers_dimer}
	\small
	\begin{tabular}{lrrrrr}
		\toprule
		System       & E(internal) & $\Delta E^\textit{GIST}$ & $\Delta S^\textit{GIST}$ & $\Delta S^\textit{scaled}$ & total \\
		\midrule
		complex      & -1303.4 & -361.2 & -233.1 & -139.9 & -192.0 \\
		streptavidin & -1180.7 & -360.8 & -242.4 & -145.4 & -188.4 \\
		biotin       & -24.0   &  -98.1 &  -35.1 &  -21.1 & -105.4 \\
		Diff         & -98.7   &   97.7 &   44.4 &   26.6 &  -27.6
	\end{tabular}
\end{table}

Even though streptavidin-biotin is known to be a very stable complex, the solvation energy favors the dissociation.
This is expected: if the molecules were not able to form any interactions, but interacted fully with the water, they would not form a complex.

In this case, we find that the energy of solvation and the internal energy of the complex more or less cancel out, indicating that binding is largely entropy-driven in this case.
This is somewhat surprising, since isothermal titration calorimetry (ITC) of biotin-streptavidin shows strong enthalpic binding contributions.\cite{mpye2020-biotin-itc}\cite{hyre2006-biotin-itc}

\subsection{Further steps}
%\section{Content and links}
%
%A tutorial will normally draw on additional files and materials; clearly indicate where and how these are available, with links, and how they are being archived for the long-term and maintained so they stay current.
%You will likely want to reference your GitHub repository as a central point to access all of this information, and then the GitHub repository may link out to other content as needed.

\section{Checklists}
%Tutorials do not necessarily require the use of a checklist as in Best Practices documents; however, they can include these if desired.
%Several useful checklist formats are available, with examples presented in \texttt{sample-document.tex} in \url{github.com/livecomsjournal/article_templates/templates}.
%One example is shown here.

% Here is a single-column checklist that consists of multiple sub-checklists
\begin{Checklists}

\begin{checklist}{Simulation settings}
\end{checklist}

\begin{checklist}{Obtaining absolute $\Delta G_\textup{solv}$ }
\end{checklist}

\begin{checklist}{A list}
\textbf{Single-column checklists are also straightforward by removing the asterisk}
\begin{itemize}
\item First thing let's do an item which breaks across lines to see how that looks
\item Also remember
\item And finally
\end{itemize}
\end{checklist}
%
%\begin{checklist}{Another list}
%\textbf{This is some further description.}
%\begin{itemize}
%\item First thing
%\item Also remember
%\item And finally
%\end{itemize}
%\end{checklist}

\end{Checklists}








\section*{Author Contributions}
%%%%%%%%%%%%%%%%
% This section mustt describe the actual contributions of
% author. Since this is an electronic-only journal, there is
% no length limit when you describe the authors' contributions,
% so we recommend describing what they actually did rather than
% simply categorizing them in a small number of
% predefined roles as might be done in other journals.
%
% See the policies ``Policies on Authorship'' section of https://livecoms.github.io
% for more information on deciding on authorship and author order.
%%%%%%%%%%%%%%%%

(Explain the contributions of the different authors here)

% We suggest you preserve this comment:
For a more detailed description of author contributions,
see the GitHub issue tracking and changelog at \githubrepository.

\section*{Other Contributions}
%%%%%%%%%%%%%%%
% You should include all people who have filed issues that were
% accepted into the paper, or that upon discussion altered what was in the paper.
% Multiple significant contributions might mean that the contributor
% should be moved to authorship at the discretion of the a
%
% See the policies ``Policies on Authorship'' section of https://livecoms.github.io for
% more information on deciding on authorship and author order.
%%%%%%%%%%%%%%%

(Explain the contributions of any non-author contributors here)
% We suggest you preserve this comment:
For a more detailed description of contributions from the community and others, see the GitHub issue tracking and changelog at \githubrepository.

\section*{Potentially Conflicting Interests}
%%%%%%%j
%Declare any potentially competing interests, financial or otherwise
%%%%%%%

Declare any potentially conflicting interests here, whether or not they pose an actual conflict in your view.

\section*{Funding Information}
%%%%%%%
% Authors should acknowledge funding sources here. Reference specific grants.
%%%%%%%
FMS acknowledges the support of NSF grant CHE-1111111.

\section*{Author Information}
\makeorcid

\bibliography{bibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% APPENDICES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\appendix


\end{document}
